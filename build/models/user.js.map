{"version":3,"sources":["../../src/models/user.js"],"names":["module","exports","sequelize","DataTypes","User","define","username","type","STRING","allowNull","unique","validate","notEmpty","msg","len","args","isUnique","value","findOne","where","user","Error","email","isEmail","password","bio","TEXT","dob","DATE","avatar","associate","models","prototype","findByCredentials","bcrypt","compare","isPasswordMatch","beforeCreate","hash"],"mappings":"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","sourcesContent":["/* eslint-disable no-undef */\nimport bcrypt from 'bcrypt'\nimport jwt from 'jsonwebtoken'\n\nmodule.exports = (sequelize, DataTypes) => {\n    const User = sequelize.define(\n        'User',\n        {\n            username: {\n                type: DataTypes.STRING,\n                allowNull: false,\n                unique: true,\n                validate: {\n                    notEmpty: {\n                        msg: 'Username is required.',\n                    },\n                    len: {\n                        args: [3, 15],\n                        msg: 'Username length should be between 3 and 15 characters.',\n                    },\n                    async isUnique(value) {\n                        const user = await User.findOne({ where: { username: value } })\n                        if (user) {\n                            throw new Error('A user with that username already exists.')\n                        }\n                    },\n                },\n            },\n            email: {\n                type: DataTypes.STRING,\n                allowNull: false,\n                unique: true,\n                validate: {\n                    isEmail: {\n                        msg: 'Invalid email. Provide a correct email.',\n                    },\n                    async isUnique(value) {\n                        const user = await User.findOne({ where: { email: value } })\n                        if (user) {\n                            throw new Error('A user with that email already exists.')\n                        }\n                    },\n                },\n            },\n            password: {\n                type: DataTypes.STRING,\n                allowNull: false,\n                validate: {\n                    len: {\n                        args: [6, 100],\n                        msg: 'Password should be more than 5 characters.',\n                    },\n                },\n            },\n            bio: {\n                type: DataTypes.TEXT,\n                validate: {\n                    len: {\n                        args: [10, 500],\n                        msg: 'Bio should be more than 10 characters and less than 500 characters',\n                    },\n                },\n            },\n            dob: {\n                type: DataTypes.DATE,\n            },\n            avatar: {\n                type: DataTypes.STRING,\n            },\n        },\n        {}\n    )\n    User.associate = function(models) {\n        // associations can be defined here\n    }\n    User.prototype.findByCredentials = async (username, password) => {\n        const user = await User.findOne({ username })\n        if (!user) {\n            throw new Error('Invalid login credentials')\n        }\n        const isPasswordMatch = await bcrypt.compare(password, user.password)\n        if (!isPasswordMatch) {\n            throw new Error('Invalid login credentials')\n        }\n        return user\n    }\n\n    // Hash the user password before saving it.\n    User.beforeCreate(async user => {\n        try {\n            user.password = await bcrypt.hash(user.password, 8)\n        } catch (error) {\n            throw new Error('Something went wrong')\n        }\n    })\n\n    return User\n}\n"],"file":"user.js"}